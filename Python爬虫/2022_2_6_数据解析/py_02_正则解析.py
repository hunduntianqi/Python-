"""
    re解析-正则表达式:一种使用表达式的方式对字符串进行匹配的语法规则
     我们抓取到的网页源代码本质上是一个超长的字符串
     正则表达式的优点:速度快,效率高,准确性高
                缺点:新手上手难度高
     正则语法:使用元字符进行排列组合用来匹配字符串
     元字符:具有固定含义的特殊符号
     常用元字符:
        1.‘.’-匹配除换行符以外的任意字符
        2.‘/w’-匹配字母或数字或下划线
        3.‘/s’-匹配任意的空白符
        4.‘/d’-匹配数字
        5.‘/n’-匹配一个换行符
        6.‘/t’-匹配一个制表符
        7.‘^’-匹配字符串的开始
        8.‘$’-匹配字符串的结尾
        9.‘/W’-匹配非字母或数字或下划线
        10.‘/D’-匹配非数字
        11.‘/S’-匹配非空白符
        12.‘a丨b’-匹配字符a或字符b
        13.‘()’-匹配括号内的表达式,也表示一个组
        14.‘[...]’-匹配字符组中的字符
        15.‘[^...]’-匹配除了字符组中字符的所有字符
     量词:控制前面的元字符出现的次数
        1.‘*’-重复零次或更多次
        2.‘+’-重复一次或更多次
        3.‘？’-重复零次或一次
        4.‘{n}’-重复n次
        5.‘{n,}’-重复n次或更多次
        6.‘{n,m}’-重复n到m次
     贪婪匹配和惰性匹配:
        1.“.*”/'.+'/'.?'-贪婪匹配:表示在整个表达式匹配成功的前提下, 尽可能多的匹配
        2.“.*？”/'.+?'/'.??'-惰性匹配:表示在整个表达式匹配成功的前提下, 尽可能少的匹配

    re模块使用流程:
        方法一:
            r_list = re.findall('正则表达式', html, re.S)
            该方法返回结果为列表
        方法二:
            pattern = re.compile('正则表达式', re.S)
            r_list = pattern.findall(html)
        注意:
            1. findall()方法的到的结果一定为列表
            2. re.S作用为使正则表达式元字符.可匹配\n在内的所有字符
        匹配任意一个字符正则表达式:
            方法一:
                pattern = re.compile('[/s/S]')
                result = pattern.findall(html)
            方法二:
                pattern = re.compile('.*', re.S)
                result = pattern.findall(html)
    正则表达式分组匹配:
        匹配时先按照整体正则匹配, 然后再提取分组()中的内容
        如果有2个及以上分组(), 在结果中以元组形式显示[(), (), ()...]

    findall:匹配字符串中所有符合正则的内容,返回一个列表
    print(re.findall(r"\d+", '我的电话号是:17320101759,她的电话是:13480194858'))

    finditer:匹配字符串中所有的内容,返回一个迭代器,从迭代器中拿到内容需要.group()
    it = re.finditer(r"\d+", '我的电话号是:17320101759,她的电话是:13480194858')
    print(it)
    for i in it:
        print(i.group())

    search返回的结果是match对象,拿到内容需要.group(),找到一个符合正则的内容就结束
    s = re.search(r"\d+", '我的电话号是:17320101759,她的电话是:13480194858')
    print(s.group())

    match是从字符串头部开始匹配,第一个字符不符合正则会报错
    m = re.match(r"\d+", '我的电话号是:17320101759,她的电话是:13480194858')
    print(m.group())

    compile可以预加载正则表达式,可以提高一点效率
    obj = re.compile(r'\d+')  # 用obj来代表正则‘\d+’
    ret = obj.finditer('我的电话号是:17320101759,她的电话是:13480194858')
    for i in ret:
        print(i.group())

    print(obj.findall('我的电话号是:17320101759,她的电话是:13480194858'))

"""


"""
面向对象的三大特征：
1.封装：根据职责将属性和方法封装到一个抽象的类中
2.继承：实现代码的重用,相同的代码不需要重复编写
3.多态：不同的对象调用相同的方法,产生不同的执行结果,增加代码的灵活度
"""

"""
单继承：
 1. 继承的概念、语法、特点：
    继承的概念：子类拥有父类所有的方法和属性
    子类继承父类,可以直接拥有父类已封装好的方法,不需要再次编写
    子类除了使用父类的方法,还可以根据需求封装子类特有的属性和方法！！！
2. 继承的语法：
    class 子类名(父类名)：
        子类特有的方法和属性...(如果不需要编写,直接pass即可)
3.专业术语：
    如以下例子：
    3.1 Dog类是Animal类的子类,Animal类是Dog类的父类,Dog类从Animal类继承
    3.2 Dog类是Animal的派生类,Animal类时Dog类的基类,Dog类从Animal类派生
4.继承的传递性：
    4.1 C类从B类继承,B类从A类继承
    4.2 C类具有B类和A类的所有属性和方法
    子类拥有父类以及父类的父类中封装的所有属性和方法
    注意：继承自同一父类的子类之间,如果没有直接的继承关系（一个子类继承另一个子类）,不能调用其他子类的属性和方法！！！
5.方法的重写：
    5.1 应用场景：父类的方法实现不能满足子类需求时,可以对方法进行重写
    5.2 重写方法的两种情况：
      5.2.1 覆盖父类的方法
        应用场景：父类的方法实现和子类的方法实现完全不同,可以在子类中重新编写父类的方法
                重写后只会调用父类中重写的方法,不再调用父类封装的方法,相当于在子类中定义了一个
                和父类同名的方法并实现
      5.2.2 对父类方法进行扩展
        应用场景：在开发中,父类原本封装的方法是实现子类方法的一部分,可以对父类方法进行扩展
        扩展方式：
            1.在子类中重写父类的方法
            2.在需要的位置使用super().父类方法来调用父类方法的执行
            3.代码其他位置针对子类的需求,编写子类特有的代码实现
        关于super：
            1.在Python中super是一个特殊的类
            2.super()是使用super类创建的对象
            3.最常使用的场景就是在重写父类方法时,调用在父类中封装的方法实现
6.父类的私有属性和方法：
    6.1 子类对象不能在自己的方法内部直接访问父类的私有属性或私有方法
    6.2子类对象可以通过父类的公有方法间接访问到私有属性或私有方法
      6.2.1 私有属性、方法是对象的隐私,不对外公开,外界以及子类都不能直接访问
      6.2.2 私有属性、方法通常用于做一些内部的事情
"""
#
#
# class Animal:
#
#     def eat(self):
#         print('吃')
#
#     def drink(self):
#         print('喝')
#
#     def run(self):
#         print('跑')
#
#     def sleep(self):
#         print('睡')
#
#
# class Dog(Animal):  # 子类继承父类,拥有父类所有的属性和方法,不需要再次编写
#
#     def bark(self):  # 封装子类特有的方法
#         print('汪汪汪...')
#
#
# class Bird(Animal):
#
#     def fly(self):
#         print('会飞行')
#
#
# class XiaoTianQuan(Dog):
#
#     def fly(self):
#         print('会飞行')
#
#     # # 重写继承自Dog类中的bark方法,子类的对象调用只时会调用重写的方法
#     # def bark(self):
#     #     print('叫的跟神一样...')
#
#     # 对父类中的方法进行扩展..
#     def bark(self):
#         # 1.针对特有需求编写子类代码
#         print('神一样的叫唤...')
#         # 2.使用super()调用父类封装的方法(还可以使用父类名.方法(self)调用父类方法,但不推荐使用)！！！
#         super().bark()
#         # 如果使用当前子类名调用方法,会形成递归调用,出现死循环！！！
#         # Dog.bark(self)
#         # XiaoTianQuan.bark(self)  # 此代码会形成递归调用
#         # 3.增加其他子类需要的代码
#         print('$%^$%^$%^$%^$%^')
#
#
# # wangcai = Animal()
# #
# # tom = Dog()
# # tom.eat()
# # tom.drink()
# # tom.run()
# # tom.sleep()
# # tom.bark()
#
#
# xiaotianquan = XiaoTianQuan()
# xiaotianquan.bark()
# # xiaotianquan.eat()
# # xiaotianquan.drink()
# # xiaotianquan.run()
# # xiaotianquan.sleep()
# # xiaotianquan.fly()

"""
多继承：
1.概念：
 子类可以拥有多个父类,并且具有所有父类的属性和方法
2.语法：
 class 子类名(父类1, 父类2, .....):
    pass(或子类特有属性、方法代码)
3.python中的MRO方法--方法搜索顺序：
 3.1 python中针对类提供了一个内置属性__mro__可以查看方法搜索顺序
 3.2 MRO主要用于在多继承时判断方法、属性的调用路径
  3.2.1 在搜索方法时,是按照__mro__的输出结果从左至右的顺序查找的
  3.2.2 如果在当前类中找到方法,就直接执行,不再搜索
  3.2.3 如果没有找到,就查找下一个类,找到就直接执行,不再搜索
  3.2.4 如果找到最后一个类还没有找到方法,程序报错！！
"""


class A:

    def test(self):
        print('test方法！！')


class B:

    def demo(self):
        print('demo方法!!!')


class C(A, B):
    pass


# 创建子类对象
c = C()

c.test()
c.demo()
print(C.__mro__)